{% extends 'base.html.twig' %}

{% block body %}
<div data-controller="sidebar">
    {# Mobile sidebar overlay #}
    <div data-sidebar-target="overlay" class="hidden fixed inset-0 z-40 bg-gray-600 bg-opacity-75 transition-opacity lg:hidden"></div>

    {# Mobile sidebar #}
    <div data-sidebar-target="sidebar" class="fixed inset-y-0 left-0 z-50 w-72 -translate-x-full transform transition-transform duration-300 ease-in-out lg:hidden">
        <div class="flex grow flex-col gap-y-5 overflow-y-auto bg-white px-6 pb-4 ring-1 ring-gray-900/10">
            <div class="flex h-16 shrink-0 items-center justify-between">
                <div class="flex items-center">
                    <span class="text-2xl">ðŸ“‹</span>
                    <span class="ml-2 text-xl font-bold text-gray-900">ZohoClone</span>
                </div>
                <button type="button" data-action="click->sidebar#close" class="-m-2.5 p-2.5 text-gray-700">
                    <span class="sr-only">Close sidebar</span>
                    <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <nav class="flex flex-1 flex-col">
                <ul role="list" class="flex flex-1 flex-col gap-y-7">
                    <li>
                        <ul role="list" class="-mx-2 space-y-1">
                            <li>
                                <a href="{{ path('app_dashboard') }}" class="{{ app.request.get('_route') == 'app_dashboard' ? 'bg-gray-50 text-primary-600' : 'text-gray-700 hover:bg-gray-50 hover:text-primary-600' }} group flex gap-x-3 rounded-md p-2 text-sm font-semibold leading-6">
                                    <svg class="h-6 w-6 shrink-0" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="m2.25 12 8.954-8.955c.44-.439 1.152-.439 1.591 0L21.75 12M4.5 9.75v10.125c0 .621.504 1.125 1.125 1.125H9.75v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21h4.125c.621 0 1.125-.504 1.125-1.125V9.75M8.25 21h8.25" />
                                    </svg>
                                    Dashboard
                                </a>
                            </li>
                            <li>
                                <a href="{{ path('app_project_index') }}" class="{{ app.request.get('_route') starts with 'app_project' ? 'bg-gray-50 text-primary-600' : 'text-gray-700 hover:bg-gray-50 hover:text-primary-600' }} group flex gap-x-3 rounded-md p-2 text-sm font-semibold leading-6">
                                    <svg class="h-6 w-6 shrink-0" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 12.75V12A2.25 2.25 0 0 1 4.5 9.75h15A2.25 2.25 0 0 1 21.75 12v.75m-8.69-6.44-2.12-2.12a1.5 1.5 0 0 0-1.061-.44H4.5A2.25 2.25 0 0 0 2.25 6v12a2.25 2.25 0 0 0 2.25 2.25h15A2.25 2.25 0 0 0 21.75 18V9a2.25 2.25 0 0 0-2.25-2.25h-5.379a1.5 1.5 0 0 1-1.06-.44Z" />
                                    </svg>
                                    Projects
                                </a>
                            </li>
                            <li>
                                <a href="{{ path('app_task_my_tasks') }}" class="{{ app.request.get('_route') == 'app_task_my_tasks' ? 'bg-gray-50 text-primary-600' : 'text-gray-700 hover:bg-gray-50 hover:text-primary-600' }} group flex gap-x-3 rounded-md p-2 text-sm font-semibold leading-6">
                                    <svg class="h-6 w-6 shrink-0" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75 11.25 15 15 9.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" />
                                    </svg>
                                    My Tasks
                                </a>
                            </li>
                        </ul>
                    </li>
                    {% if recent_projects is defined and recent_projects|length > 0 %}
                    <li>
                        <div class="text-xs font-semibold leading-6 text-gray-400">Recent Projects</div>
                        <ul role="list" class="-mx-2 mt-2 space-y-1">
                            {% for project in recent_projects %}
                            <li>
                                <a href="{{ path('app_project_show', {id: project.id}) }}" class="text-gray-700 hover:bg-gray-50 hover:text-primary-600 group flex gap-x-3 rounded-md p-2 text-sm font-semibold leading-6">
                                    <span class="flex h-6 w-6 shrink-0 items-center justify-center rounded-lg border border-gray-200 bg-white text-[0.625rem] font-medium text-gray-400">
                                        {{ project.name|slice(0, 1)|upper }}
                                    </span>
                                    <span class="truncate">{{ project.name }}</span>
                                </a>
                            </li>
                            {% endfor %}
                        </ul>
                    </li>
                    {% endif %}
                    <li class="mt-auto">
                        <a href="{{ path('app_profile') }}" class="group -mx-2 flex gap-x-3 rounded-md p-2 text-sm font-semibold leading-6 text-gray-700 hover:bg-gray-50 hover:text-primary-600">
                            <svg class="h-6 w-6 shrink-0 text-gray-400 group-hover:text-primary-600" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87.074.04.147.083.22.127.325.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 0 1 1.37.49l1.296 2.247a1.125 1.125 0 0 1-.26 1.431l-1.003.827c-.293.241-.438.613-.43.992a7.723 7.723 0 0 1 0 .255c-.008.378.137.75.43.991l1.004.827c.424.35.534.955.26 1.43l-1.298 2.247a1.125 1.125 0 0 1-1.369.491l-1.217-.456c-.355-.133-.75-.072-1.076.124a6.47 6.47 0 0 1-.22.128c-.331.183-.581.495-.644.869l-.213 1.281c-.09.543-.56.94-1.11.94h-2.594c-.55 0-1.019-.398-1.11-.94l-.213-1.281c-.062-.374-.312-.686-.644-.87a6.52 6.52 0 0 1-.22-.127c-.325-.196-.72-.257-1.076-.124l-1.217.456a1.125 1.125 0 0 1-1.369-.49l-1.297-2.247a1.125 1.125 0 0 1 .26-1.431l1.004-.827c.292-.24.437-.613.43-.991a6.932 6.932 0 0 1 0-.255c.007-.38-.138-.751-.43-.992l-1.004-.827a1.125 1.125 0 0 1-.26-1.43l1.297-2.247a1.125 1.125 0 0 1 1.37-.491l1.216.456c.356.133.751.072 1.076-.124.072-.044.146-.086.22-.128.332-.183.582-.495.644-.869l.214-1.28Z" />
                                <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" />
                            </svg>
                            Settings
                        </a>
                    </li>
                </ul>
            </nav>
        </div>
    </div>

    {# Desktop sidebar #}
    {% include 'components/_sidebar.html.twig' %}

    <div class="lg:pl-72">
        {% include 'components/_header.html.twig' %}

        <main class="py-10">
            <div class="px-4 sm:px-6 lg:px-8">
                {% include 'components/_flash.html.twig' %}
                {% block content %}{% endblock %}
            </div>
        </main>
    </div>

    {# Task Panel Off-Canvas (slides from right) #}
    <div id="task-panel-overlay" class="fixed inset-0 z-[60] bg-gray-600 bg-opacity-50 transition-opacity duration-300 opacity-0 pointer-events-none" onclick="closeTaskPanel()"></div>
    <div id="task-panel" class="fixed inset-y-0 right-0 z-[70] w-full max-w-xl transform translate-x-full transition-transform duration-300 ease-in-out bg-white shadow-xl">
        <div id="task-panel-content" class="h-full">
            {# Content loaded via AJAX #}
            <div class="flex items-center justify-center h-full">
                <svg class="animate-spin h-8 w-8 text-primary-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
            </div>
        </div>
    </div>

    <script>
    // Base path for all API calls (handles proxy prefix)
    window.BASE_PATH = '{{ app.request.basePath }}';

    function openTaskPanel(taskId, updateUrl = true) {
        const panel = document.getElementById('task-panel');
        const overlay = document.getElementById('task-panel-overlay');
        const content = document.getElementById('task-panel-content');

        // Update URL with task param
        if (updateUrl) {
            const url = new URL(window.location);
            url.searchParams.set('task', taskId);
            window.history.pushState({ taskId }, '', url);
        }

        // Show loading state
        content.innerHTML = `
            <div class="flex items-center justify-center h-full">
                <svg class="animate-spin h-8 w-8 text-primary-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
            </div>
        `;

        // Show panel
        panel.classList.remove('translate-x-full');
        overlay.classList.remove('opacity-0', 'pointer-events-none');

        // Prevent body scroll
        document.body.style.overflow = 'hidden';

        // Fetch task details
        fetch(`${BASE_PATH}/tasks/${taskId}/panel`, {
            headers: {
                'X-Requested-With': 'XMLHttpRequest'
            }
        })
        .then(response => {
            if (!response.ok) throw new Error('Failed to load task');
            return response.text();
        })
        .then(html => {
            content.innerHTML = html;
            // Trigger Vue component mounting for dynamically loaded content
            if (typeof mountVueComponents === 'function') {
                mountVueComponents();
            }
        })
        .catch(error => {
            console.error('Error loading task:', error);
            content.innerHTML = `
                <div class="flex flex-col items-center justify-center h-full text-center p-6">
                    <svg class="h-12 w-12 text-red-400 mb-4" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z" />
                    </svg>
                    <p class="text-gray-900 font-medium">Failed to load task</p>
                    <p class="text-gray-500 text-sm mt-1">Please try again</p>
                    <button onclick="closeTaskPanel()" class="mt-4 text-sm text-primary-600 hover:text-primary-500">Close</button>
                </div>
            `;
        });
    }

    function closeTaskPanel(updateUrl = true) {
        const panel = document.getElementById('task-panel');
        const overlay = document.getElementById('task-panel-overlay');

        panel.classList.add('translate-x-full');
        overlay.classList.add('opacity-0', 'pointer-events-none');

        // Restore body scroll
        document.body.style.overflow = '';

        // Remove task param from URL
        if (updateUrl) {
            const url = new URL(window.location);
            url.searchParams.delete('task');
            window.history.pushState({}, '', url);
        }
    }

    // Handle browser back/forward buttons
    window.addEventListener('popstate', function(e) {
        const url = new URL(window.location);
        const taskId = url.searchParams.get('task');
        const panel = document.getElementById('task-panel');
        const isOpen = panel && !panel.classList.contains('translate-x-full');

        if (taskId && !isOpen) {
            openTaskPanel(taskId, false);
        } else if (!taskId && isOpen) {
            closeTaskPanel(false);
        }
    });

    // Open task panel if task param exists on page load
    document.addEventListener('DOMContentLoaded', function() {
        const url = new URL(window.location);
        const taskId = url.searchParams.get('task');
        if (taskId) {
            openTaskPanel(taskId, false);
        }
    });

    // Close on Escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            const panel = document.getElementById('task-panel');
            if (panel && !panel.classList.contains('translate-x-full')) {
                closeTaskPanel();
            }
            // Also close any open dropdowns
            closeAllDropdowns();
        }
    });

    // ===== INLINE EDITING FUNCTIONS =====

    // Close all dropdowns
    function closeAllDropdowns() {
        document.querySelectorAll('.status-dropdown, .priority-dropdown, .milestone-dropdown, .add-assignee-dropdown').forEach(d => {
            d.classList.add('hidden');
        });
    }

    // Click outside to close dropdowns
    document.addEventListener('click', function(e) {
        if (!e.target.closest('.status-badge-btn, .status-dropdown, .priority-badge-btn, .priority-dropdown, .milestone-btn, .milestone-dropdown, .add-assignee-btn, .add-assignee-dropdown')) {
            closeAllDropdowns();
        }
    });

    // Toggle Status Dropdown
    function toggleStatusDropdown(btn) {
        const dropdown = btn.parentElement.querySelector('.status-dropdown');
        const isHidden = dropdown.classList.contains('hidden');
        closeAllDropdowns();
        if (isHidden) {
            dropdown.classList.remove('hidden');
        }
    }

    // Toggle Priority Dropdown
    function togglePriorityDropdown(btn) {
        const dropdown = btn.parentElement.querySelector('.priority-dropdown');
        const isHidden = dropdown.classList.contains('hidden');
        closeAllDropdowns();
        if (isHidden) {
            dropdown.classList.remove('hidden');
        }
    }

    // Toggle Milestone Dropdown
    function toggleMilestoneDropdown(btn) {
        const dropdown = btn.parentElement.querySelector('.milestone-dropdown');
        const isHidden = dropdown.classList.contains('hidden');
        closeAllDropdowns();
        if (isHidden) {
            dropdown.classList.remove('hidden');
        }
    }

    // Update Task Status
    async function updateTaskStatus(taskId, status, btn) {
        const statusLabels = {
            'todo': 'To Do',
            'in_progress': 'In Progress',
            'in_review': 'In Review',
            'completed': 'Completed'
        };
        const statusColors = {
            'todo': 'bg-gray-100 text-gray-700',
            'in_progress': 'bg-blue-100 text-blue-700',
            'in_review': 'bg-yellow-100 text-yellow-700',
            'completed': 'bg-green-100 text-green-700'
        };

        try {
            const response = await fetch(`${BASE_PATH}/tasks/${taskId}/status`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({ status: status })
            });

            if (!response.ok) throw new Error('Failed to update status');

            const data = await response.json();

            // Update the badge
            const badgeBtn = btn.closest('.status-dropdown').previousElementSibling;
            badgeBtn.querySelector('.status-label').textContent = statusLabels[status];
            badgeBtn.className = badgeBtn.className.replace(/bg-\w+-100 text-\w+-700/g, '');
            badgeBtn.classList.add(...statusColors[status].split(' '));

            closeAllDropdowns();
            Toastr.success('Status updated');

            // Notify other components (e.g., KanbanBoard)
            document.dispatchEvent(new CustomEvent('task-updated', {
                detail: { taskId, field: 'status', value: status, label: statusLabels[status] }
            }));
        } catch (error) {
            console.error('Error updating status:', error);
            Toastr.error('Failed to update status');
        }
    }

    // Update Task Priority
    async function updateTaskPriority(taskId, priority, btn) {
        const priorityLabels = {
            'none': 'None',
            'low': 'Low',
            'medium': 'Medium',
            'high': 'High'
        };
        const priorityColors = {
            'none': 'bg-gray-100 text-gray-700',
            'low': 'bg-blue-100 text-blue-700',
            'medium': 'bg-yellow-100 text-yellow-700',
            'high': 'bg-red-100 text-red-700'
        };

        try {
            const response = await fetch(`${BASE_PATH}/tasks/${taskId}/priority`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({ priority: priority })
            });

            if (!response.ok) throw new Error('Failed to update priority');

            // Update the badge
            const badgeBtn = btn.closest('.priority-dropdown').previousElementSibling;
            badgeBtn.querySelector('.priority-label').textContent = priorityLabels[priority];
            badgeBtn.className = badgeBtn.className.replace(/bg-\w+-100 text-\w+-700/g, '');
            badgeBtn.classList.add(...priorityColors[priority].split(' '));

            closeAllDropdowns();
            Toastr.success('Priority updated');

            // Notify other components (e.g., KanbanBoard)
            document.dispatchEvent(new CustomEvent('task-updated', {
                detail: { taskId, field: 'priority', value: priority, label: priorityLabels[priority] }
            }));
        } catch (error) {
            console.error('Error updating priority:', error);
            Toastr.error('Failed to update priority');
        }
    }

    // Update Task Milestone
    async function updateTaskMilestone(taskId, milestoneId, milestoneName, btn) {
        try {
            const response = await fetch(`${BASE_PATH}/tasks/${taskId}/milestone`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({ milestone: milestoneId })
            });

            if (!response.ok) throw new Error('Failed to update milestone');

            // Update the label
            const milestoneBtn = btn.closest('.milestone-dropdown').previousElementSibling;
            milestoneBtn.querySelector('.milestone-label').textContent = milestoneName;

            closeAllDropdowns();
            Toastr.success('Milestone updated');

            // Notify other components (e.g., KanbanBoard)
            document.dispatchEvent(new CustomEvent('task-updated', {
                detail: { taskId, field: 'milestone', value: milestoneId, label: milestoneName }
            }));
        } catch (error) {
            console.error('Error updating milestone:', error);
            Toastr.error('Failed to update milestone');
        }
    }

    // Update Start Date
    async function updateStartDate(input) {
        const endpoint = input.dataset.endpoint;
        const value = input.value;
        const originalValue = input.dataset.original || '';

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({ startDate: value || null })
            });

            const data = await response.json();

            if (!response.ok) {
                // Revert to original value
                input.value = originalValue;
                throw new Error(data.error || 'Failed to update start date');
            }

            // Update the original value
            input.dataset.original = value;

            // Remove placeholder if it exists
            const placeholder = input.parentElement.querySelector('.start-date-placeholder');
            if (placeholder && value) {
                placeholder.remove();
            }

            Toastr.success('Start date updated');
        } catch (error) {
            console.error('Error updating start date:', error);
            Toastr.error(error.message || 'Failed to update start date');
        }
    }

    // Update Due Date
    async function updateDueDate(input) {
        const endpoint = input.dataset.endpoint;
        const value = input.value;
        const originalValue = input.dataset.original || '';

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({ dueDate: value || null })
            });

            const data = await response.json();

            if (!response.ok) {
                // Revert to original value
                input.value = originalValue;
                throw new Error(data.error || 'Failed to update due date');
            }

            // Update the original value
            input.dataset.original = value;

            // Update styling for overdue
            if (data.isOverdue) {
                input.classList.add('text-red-600', 'font-medium');
                input.classList.remove('text-gray-900');
            } else {
                input.classList.remove('text-red-600', 'font-medium');
                input.classList.add('text-gray-900');
            }

            // Remove placeholder if it exists
            const placeholder = input.parentElement.querySelector('.due-date-placeholder');
            if (placeholder && value) {
                placeholder.remove();
            }

            Toastr.success('Due date updated');

            // Notify other components (e.g., KanbanBoard)
            const taskId = endpoint.match(/\/tasks\/(\d+)\//)?.[1];
            if (taskId) {
                document.dispatchEvent(new CustomEvent('task-updated', {
                    detail: { taskId, field: 'dueDate', value: value || null }
                }));
            }
        } catch (error) {
            console.error('Error updating due date:', error);
            Toastr.error(error.message || 'Failed to update due date');
        }
    }

    // Title editing - contenteditable
    document.addEventListener('blur', async function(e) {
        if (e.target.classList.contains('editable-title')) {
            const endpoint = e.target.dataset.endpoint;
            const original = e.target.dataset.original;
            const newValue = e.target.textContent.trim();

            if (newValue === original) return;
            if (!newValue) {
                e.target.textContent = original;
                Toastr.error('Title cannot be empty');
                return;
            }

            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    body: JSON.stringify({ title: newValue })
                });

                if (!response.ok) throw new Error('Failed to update title');

                e.target.dataset.original = newValue;
                Toastr.success('Title updated');

                // Notify other components (e.g., KanbanBoard)
                const taskId = endpoint.match(/\/tasks\/(\d+)\//)?.[1];
                if (taskId) {
                    document.dispatchEvent(new CustomEvent('task-updated', {
                        detail: { taskId, field: 'title', value: newValue }
                    }));
                }
            } catch (error) {
                console.error('Error updating title:', error);
                e.target.textContent = original;
                Toastr.error('Failed to update title');
            }
        }
    }, true);

    // Prevent Enter from creating new line in title
    document.addEventListener('keydown', function(e) {
        if (e.target.classList.contains('editable-title') && e.key === 'Enter') {
            e.preventDefault();
            e.target.blur();
        }
        // Escape to cancel edit
        if (e.target.classList.contains('editable-title') && e.key === 'Escape') {
            e.target.textContent = e.target.dataset.original;
            e.target.blur();
        }
    });

    // Description editing
    function showDescriptionEditor(displayEl) {
        const container = displayEl.closest('.description-container');
        const editor = container.querySelector('.description-editor');
        const textarea = editor.querySelector('textarea');

        displayEl.classList.add('hidden');
        editor.classList.remove('hidden');
        textarea.focus();
    }

    function cancelDescriptionEdit(btn) {
        const container = btn.closest('.description-container');
        const editor = container.querySelector('.description-editor');
        const display = container.querySelector('.description-display');
        const textarea = editor.querySelector('textarea');

        textarea.value = textarea.dataset.original || '';
        editor.classList.add('hidden');
        display.classList.remove('hidden');
    }

    async function saveDescription(btn) {
        const container = btn.closest('.description-container');
        const editor = container.querySelector('.description-editor');
        const display = container.querySelector('.description-display');
        const textarea = editor.querySelector('textarea');
        const endpoint = textarea.dataset.endpoint;
        const newValue = textarea.value.trim();

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({ description: newValue })
            });

            if (!response.ok) throw new Error('Failed to update description');

            textarea.dataset.original = newValue;

            if (newValue) {
                display.textContent = newValue;
                display.classList.remove('text-gray-400', 'italic');
                display.classList.add('text-gray-600');
            } else {
                display.textContent = display.dataset.placeholder;
                display.classList.add('text-gray-400', 'italic');
                display.classList.remove('text-gray-600');
            }

            editor.classList.add('hidden');
            display.classList.remove('hidden');
            Toastr.success('Description updated');
        } catch (error) {
            console.error('Error updating description:', error);
            Toastr.error('Failed to update description');
        }
    }

    // Assignee management
    async function removeAssignee(taskId, userId, btn) {
        try {
            const response = await fetch(`${BASE_PATH}/tasks/${taskId}/assignees`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({ action: 'remove', userId: userId })
            });

            if (!response.ok) throw new Error('Failed to remove assignee');

            // Remove the chip
            const chip = btn.closest('.assignee-chip');
            chip.remove();

            // Show "No assignees" if empty
            const container = document.querySelector('.assignees-container');
            const chips = container.querySelectorAll('.assignee-chip');
            if (chips.length === 0) {
                const noMsg = document.createElement('p');
                noMsg.className = 'no-assignees-msg text-sm text-gray-400 italic mt-2';
                noMsg.textContent = 'No assignees';
                container.parentElement.appendChild(noMsg);
            }

            Toastr.success('Assignee removed');
        } catch (error) {
            console.error('Error removing assignee:', error);
            Toastr.error('Failed to remove assignee');
        }
    }

    async function showAddAssigneeDropdown(btn) {
        const container = btn.closest('.assignees-container');
        const dropdown = container.querySelector('.add-assignee-dropdown');
        const projectId = container.dataset.projectId;
        const taskId = container.dataset.taskId;

        // Position the dropdown near the button
        const btnRect = btn.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        dropdown.style.left = (btnRect.left - containerRect.left) + 'px';

        closeAllDropdowns();
        dropdown.classList.remove('hidden');

        // Load project members
        try {
            const response = await fetch(`${BASE_PATH}/projects/${projectId}/members`, {
                headers: { 'X-Requested-With': 'XMLHttpRequest' }
            });

            if (!response.ok) throw new Error('Failed to load members');

            const data = await response.json();
            const currentAssignees = Array.from(container.querySelectorAll('.assignee-chip'))
                .map(chip => chip.dataset.userId);

            // Filter out already assigned members
            const availableMembers = data.members.filter(m => !currentAssignees.includes(m.id));

            const dropdownContent = dropdown.querySelector('.py-1');
            if (availableMembers.length === 0) {
                dropdownContent.innerHTML = '<div class="px-4 py-2 text-sm text-gray-500">No more members to add</div>';
            } else {
                dropdownContent.innerHTML = availableMembers.map(member => `
                    <button type="button"
                            onclick="addAssignee('${taskId}', '${member.id}', '${member.fullName}', '${member.initials}', this)"
                            class="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 flex items-center">
                        <span class="inline-flex h-6 w-6 items-center justify-center rounded-full bg-primary-100 mr-2">
                            <span class="text-xs font-medium text-primary-700">${member.initials}</span>
                        </span>
                        ${member.fullName}
                    </button>
                `).join('');
            }
        } catch (error) {
            console.error('Error loading members:', error);
            dropdown.querySelector('.py-1').innerHTML = '<div class="px-4 py-2 text-sm text-red-500">Failed to load members</div>';
        }
    }

    async function addAssignee(taskId, userId, fullName, initials, btn) {
        try {
            const response = await fetch(`${BASE_PATH}/tasks/${taskId}/assignees`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({ action: 'add', userId: userId })
            });

            if (!response.ok) throw new Error('Failed to add assignee');

            // Add the new chip before the Add button
            const container = document.querySelector('.assignees-container');
            const addBtn = container.querySelector('.add-assignee-btn');

            const chip = document.createElement('span');
            chip.className = 'assignee-chip inline-flex items-center rounded-full bg-gray-100 py-1 pl-2 pr-1 text-sm font-medium text-gray-800';
            chip.dataset.userId = userId;
            chip.innerHTML = `
                <span class="inline-flex h-6 w-6 items-center justify-center rounded-full bg-primary-100 mr-2">
                    <span class="text-xs font-medium text-primary-700">${initials}</span>
                </span>
                ${fullName}
                <button type="button"
                        onclick="removeAssignee('${taskId}', '${userId}', this)"
                        class="ml-1 inline-flex h-5 w-5 items-center justify-center rounded-full text-gray-400 hover:bg-gray-200 hover:text-gray-600">
                    <svg class="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            `;

            container.querySelector('.assignees-list').insertBefore(chip, addBtn);

            // Remove "No assignees" message
            const noMsg = container.parentElement.querySelector('.no-assignees-msg');
            if (noMsg) noMsg.remove();

            closeAllDropdowns();
            Toastr.success('Assignee added');
        } catch (error) {
            console.error('Error adding assignee:', error);
            Toastr.error('Failed to add assignee');
        }
    }

    // Comment handling
    document.addEventListener('input', function(e) {
        if (e.target.classList.contains('comment-textarea')) {
            const btn = e.target.closest('.add-comment-form').querySelector('.add-comment-btn');
            btn.disabled = !e.target.value.trim();
        }
    });

    async function addComment(taskId, btn) {
        const form = btn.closest('.add-comment-form');
        const textarea = form.querySelector('.comment-textarea');
        const content = textarea.value.trim();

        if (!content) return;

        btn.disabled = true;
        btn.textContent = 'Posting...';

        try {
            const response = await fetch(`${BASE_PATH}/tasks/${taskId}/comments`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({ content: content })
            });

            if (!response.ok) throw new Error('Failed to add comment');

            const data = await response.json();

            // Add the new comment to the list
            const commentsList = document.querySelector('.comments-list');

            // Remove "No comments" message if present
            const noMsg = commentsList.querySelector('.no-comments-msg');
            if (noMsg) noMsg.remove();

            const commentEl = document.createElement('div');
            commentEl.className = 'comment-item bg-gray-50 rounded-lg p-3';
            commentEl.dataset.commentId = data.comment.id;
            commentEl.innerHTML = `
                <div class="flex items-center mb-2">
                    <span class="inline-flex h-6 w-6 items-center justify-center rounded-full bg-primary-100 mr-2">
                        <span class="text-xs font-medium text-primary-700">${data.comment.authorInitials}</span>
                    </span>
                    <span class="text-sm font-medium text-gray-900">${data.comment.authorName}</span>
                    <span class="ml-auto text-xs text-gray-500">${data.comment.createdAt}</span>
                </div>
                <p class="text-sm text-gray-600 whitespace-pre-wrap">${escapeHtml(data.comment.content)}</p>
            `;

            // Insert at the beginning (newest first)
            commentsList.prepend(commentEl);

            // Update comment count
            const countSpan = document.querySelector('.comments-count');
            const currentCount = parseInt(countSpan.textContent.replace(/[()]/g, '') || '0');
            countSpan.textContent = `(${currentCount + 1})`;

            // Clear the form
            textarea.value = '';
            btn.textContent = 'Post Comment';
            btn.disabled = true;

            Toastr.success('Comment added');
        } catch (error) {
            console.error('Error adding comment:', error);
            btn.textContent = 'Post Comment';
            btn.disabled = false;
            Toastr.error('Failed to add comment');
        }
    }

    // Helper function to escape HTML
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // ===== TAB SWITCHING =====
    function switchTab(tabName, btn) {
        // Update tab buttons
        const tabBtns = btn.closest('.task-panel-tabs').querySelectorAll('.tab-btn');
        tabBtns.forEach(b => {
            if (b.dataset.tab === tabName) {
                b.classList.add('text-gray-700', 'border-primary-600');
                b.classList.remove('text-gray-500', 'border-transparent');
            } else {
                b.classList.remove('text-gray-700', 'border-primary-600');
                b.classList.add('text-gray-500', 'border-transparent');
            }
        });

        // Update tab content
        const tabContents = btn.closest('.task-panel-tabs').querySelectorAll('.tab-content');
        tabContents.forEach(content => {
            if (content.id === `tab-${tabName}`) {
                content.classList.remove('hidden');
            } else {
                content.classList.add('hidden');
            }
        });
    }

    // ===== CHECKLIST FUNCTIONS =====

    // Add checklist item
    async function addChecklistItem(taskId, input) {
        const title = input.value.trim();
        if (!title) return;

        const originalValue = input.value;
        input.value = '';
        input.disabled = true;

        try {
            const response = await fetch(`${BASE_PATH}/tasks/${taskId}/checklists`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({ title: title })
            });

            if (!response.ok) throw new Error('Failed to add checklist item');

            const data = await response.json();
            const item = data.item;

            // Remove "No checklist items" message if present
            const noMsg = document.querySelector('.no-checklist-msg');
            if (noMsg) noMsg.remove();

            // Add the new item to the list
            const checklistItems = document.querySelector('.checklist-items');
            const itemEl = document.createElement('div');
            itemEl.className = 'checklist-item group flex items-center gap-2 p-2 rounded-md hover:bg-gray-50';
            itemEl.dataset.itemId = item.id;
            itemEl.innerHTML = `
                <div class="checklist-drag-handle cursor-grab text-gray-400 opacity-0 group-hover:opacity-100 transition-opacity">
                    <svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
                    </svg>
                </div>
                <input type="checkbox"
                       class="checklist-checkbox h-4 w-4 rounded border-gray-300 text-primary-600 focus:ring-primary-500"
                       onchange="toggleChecklistItem('${taskId}', '${item.id}', this)">
                <span class="checklist-item-title flex-1 text-sm cursor-pointer text-gray-900"
                      onclick="editChecklistItem(this, '${taskId}', '${item.id}')"
                      data-original="${escapeHtml(item.title)}">${escapeHtml(item.title)}</span>
                <button type="button"
                        onclick="deleteChecklistItem('${taskId}', '${item.id}', this)"
                        class="checklist-delete-btn opacity-0 group-hover:opacity-100 transition-opacity text-gray-400 hover:text-red-600">
                    <svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0" />
                    </svg>
                </button>
            `;
            checklistItems.appendChild(itemEl);

            // Update progress
            updateChecklistProgress();

            input.disabled = false;
            input.focus();
            Toastr.success('Checklist item added');
        } catch (error) {
            console.error('Error adding checklist item:', error);
            input.value = originalValue;
            input.disabled = false;
            Toastr.error('Failed to add checklist item');
        }
    }

    // Toggle checklist item
    async function toggleChecklistItem(taskId, itemId, checkbox) {
        checkbox.disabled = true;

        try {
            const response = await fetch(`${BASE_PATH}/tasks/${taskId}/checklists/${itemId}/toggle`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                }
            });

            if (!response.ok) throw new Error('Failed to toggle checklist item');

            const data = await response.json();
            const item = data.item;

            // Update the title styling
            const itemEl = checkbox.closest('.checklist-item');
            const titleEl = itemEl.querySelector('.checklist-item-title');

            if (item.isCompleted) {
                titleEl.classList.add('line-through', 'text-gray-400');
                titleEl.classList.remove('text-gray-900');
            } else {
                titleEl.classList.remove('line-through', 'text-gray-400');
                titleEl.classList.add('text-gray-900');
            }

            checkbox.disabled = false;

            // Update progress
            updateChecklistProgress();
        } catch (error) {
            console.error('Error toggling checklist item:', error);
            checkbox.checked = !checkbox.checked;
            checkbox.disabled = false;
            Toastr.error('Failed to toggle checklist item');
        }
    }

    // Edit checklist item
    function editChecklistItem(titleEl, taskId, itemId) {
        // Don't edit if already editing
        if (titleEl.querySelector('input')) return;

        const original = titleEl.dataset.original;
        const input = document.createElement('input');
        input.type = 'text';
        input.value = original;
        input.className = 'w-full text-sm border border-gray-300 rounded px-2 py-1 focus:ring-2 focus:ring-primary-500 focus:border-primary-500';

        const saveEdit = async () => {
            const newValue = input.value.trim();

            if (!newValue) {
                titleEl.textContent = original;
                return;
            }

            if (newValue === original) {
                titleEl.textContent = original;
                return;
            }

            try {
                const response = await fetch(`${BASE_PATH}/tasks/${taskId}/checklists/${itemId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/merge-patch+json',
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    body: JSON.stringify({ title: newValue })
                });

                if (!response.ok) throw new Error('Failed to update checklist item');

                titleEl.dataset.original = newValue;
                titleEl.textContent = newValue;
                Toastr.success('Checklist item updated');
            } catch (error) {
                console.error('Error updating checklist item:', error);
                titleEl.textContent = original;
                Toastr.error('Failed to update checklist item');
            }
        };

        input.onblur = saveEdit;
        input.onkeydown = (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                input.blur();
            } else if (e.key === 'Escape') {
                input.value = original;
                input.blur();
            }
        };

        titleEl.textContent = '';
        titleEl.appendChild(input);
        input.focus();
        input.select();
    }

    // Delete checklist item
    async function deleteChecklistItem(taskId, itemId, btn) {
        const itemEl = btn.closest('.checklist-item');
        itemEl.style.opacity = '0.5';

        try {
            const response = await fetch(`${BASE_PATH}/tasks/${taskId}/checklists/${itemId}`, {
                method: 'DELETE',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest'
                }
            });

            if (!response.ok) throw new Error('Failed to delete checklist item');

            itemEl.remove();

            // Show "No checklist items" if empty
            const checklistItems = document.querySelector('.checklist-items');
            if (checklistItems.querySelectorAll('.checklist-item').length === 0) {
                const noMsg = document.createElement('p');
                noMsg.className = 'no-checklist-msg text-sm text-gray-400 italic py-4';
                noMsg.textContent = 'No checklist items yet';
                checklistItems.appendChild(noMsg);
            }

            // Update progress
            updateChecklistProgress();

            Toastr.success('Checklist item deleted');
        } catch (error) {
            console.error('Error deleting checklist item:', error);
            itemEl.style.opacity = '1';
            Toastr.error('Failed to delete checklist item');
        }
    }

    // Update checklist progress bar
    function updateChecklistProgress() {
        const checklistItems = document.querySelector('.checklist-items');
        if (!checklistItems) return;

        const items = checklistItems.querySelectorAll('.checklist-item');
        const totalCount = items.length;
        const completedCount = checklistItems.querySelectorAll('.checklist-checkbox:checked').length;

        const progressContainer = document.querySelector('.checklist-progress');
        const progressText = document.querySelector('.checklist-progress-text');
        const progressBar = document.querySelector('.checklist-progress-bar');
        const countSpan = document.querySelector('.checklist-count');

        if (progressContainer) {
            if (totalCount === 0) {
                progressContainer.classList.add('hidden');
            } else {
                progressContainer.classList.remove('hidden');
                const percentage = (completedCount / totalCount) * 100;
                progressText.textContent = `${completedCount}/${totalCount}`;
                progressBar.style.width = `${percentage}%`;
            }
        }

        if (countSpan) {
            countSpan.textContent = `(${totalCount})`;
        }
    }

    // ===== CHECKLIST DRAG AND DROP =====
    window.draggedChecklistItem = null;

    document.addEventListener('mousedown', function(e) {
        // Only allow drag to start from the handle
        const handle = e.target.closest('.checklist-drag-handle');
        const checklistItem = e.target.closest('.checklist-item');
        if (checklistItem) {
            checklistItem.draggable = !!handle;
        }
    });

    document.addEventListener('dragstart', function(e) {
        const checklistItem = e.target.closest('.checklist-item');
        if (!checklistItem) return;

        draggedChecklistItem = checklistItem;
        draggedChecklistItem.classList.add('opacity-50');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', checklistItem.dataset.itemId);
    });

    document.addEventListener('dragend', function(e) {
        if (draggedChecklistItem) {
            draggedChecklistItem.classList.remove('opacity-50');
            draggedChecklistItem = null;
        }
        // Remove all drag-over styles
        document.querySelectorAll('.checklist-item').forEach(item => {
            item.classList.remove('border-t-2', 'border-primary-500');
        });
    });

    document.addEventListener('dragover', function(e) {
        const checklistItem = e.target.closest('.checklist-item');
        if (!checklistItem || !draggedChecklistItem || checklistItem === draggedChecklistItem) return;

        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';

        // Remove previous indicators
        document.querySelectorAll('.checklist-item').forEach(item => {
            item.classList.remove('border-t-2', 'border-primary-500');
        });

        // Add indicator to current target
        checklistItem.classList.add('border-t-2', 'border-primary-500');
    });

    document.addEventListener('drop', async function(e) {
        const targetItem = e.target.closest('.checklist-item');
        if (!targetItem || !draggedChecklistItem || targetItem === draggedChecklistItem) return;

        e.preventDefault();

        const checklistContainer = document.querySelector('.checklist-items');
        const taskId = checklistContainer.dataset.taskId;
        const movedItem = draggedChecklistItem;

        // Move the dragged item before the target
        checklistContainer.insertBefore(movedItem, targetItem);

        // Remove drag-over styles
        targetItem.classList.remove('border-t-2', 'border-primary-500');

        // Get new order of item IDs
        const itemIds = Array.from(checklistContainer.querySelectorAll('.checklist-item'))
            .map(item => item.dataset.itemId);

        // Add saving indicator
        movedItem.classList.add('opacity-50');

        // Save new order to server
        try {
            const response = await fetch(`${BASE_PATH}/tasks/${taskId}/checklists/reorder`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({ itemIds: itemIds })
            });

            if (!response.ok) throw new Error('Failed to reorder');

            // Success feedback - brief highlight
            movedItem.classList.remove('opacity-50');
            movedItem.classList.add('bg-green-50');
            setTimeout(() => movedItem.classList.remove('bg-green-50'), 300);
            Toastr.success('Order updated');
        } catch (error) {
            console.error('Error reordering checklist items:', error);
            movedItem.classList.remove('opacity-50');
            Toastr.error('Failed to save new order');
        }
    });

    // ===== TAG FUNCTIONS =====
    window.tagSearchTimeout = null;
    window.selectedTagColor = '#3b82f6'; // Default blue

    // Search tags as user types
    function searchTags(input, taskId) {
        const query = input.value.trim();
        const container = input.closest('.add-tag-container');
        const dropdown = container.querySelector('.tag-dropdown');
        const createSection = dropdown.querySelector('.create-tag-section');
        const tagsGrid = dropdown.querySelector('.existing-tags-grid');
        const newTagPreview = dropdown.querySelector('.new-tag-preview');

        clearTimeout(tagSearchTimeout);

        if (query.length < 1) {
            dropdown.classList.add('hidden');
            return;
        }

        dropdown.classList.remove('hidden');

        tagSearchTimeout = setTimeout(async () => {
            try {
                const response = await fetch(`${BASE_PATH}/tags/search?q=${encodeURIComponent(query)}&limit=50`, {
                    headers: { 'X-Requested-With': 'XMLHttpRequest' }
                });

                if (!response.ok) throw new Error('Search failed');

                const data = await response.json();
                const tags = data.tags;

                // Get current tags on the task
                const currentTagIds = Array.from(document.querySelectorAll('.tags-container .tag-chip'))
                    .map(chip => chip.dataset.tagId);

                // Filter out already added tags
                const availableTags = tags.filter(t => !currentTagIds.includes(t.id));

                // Check if exact match exists
                const exactMatch = tags.find(t => t.name.toLowerCase() === query.toLowerCase());

                // Show/hide create section
                if (!exactMatch && query.length > 0) {
                    createSection.classList.remove('hidden');
                    newTagPreview.textContent = query;
                    newTagPreview.style.backgroundColor = selectedTagColor;
                    newTagPreview.style.setProperty('--tag-color', selectedTagColor);
                } else {
                    createSection.classList.add('hidden');
                }

                // Build tags grid
                if (availableTags.length > 0) {
                    tagsGrid.innerHTML = availableTags.map(tag => `
                        <button type="button"
                                onclick="addExistingTag('${taskId}', '${tag.id}', '${escapeHtml(tag.name)}', '${tag.color}')"
                                class="tag-chip inline-flex items-center text-xs font-medium text-white pl-2 pr-2 py-0.5 hover:opacity-80 transition-opacity"
                                style="background-color: ${tag.color}; --tag-color: ${tag.color};">
                            ${escapeHtml(tag.name)}
                        </button>
                    `).join('');
                } else if (exactMatch) {
                    tagsGrid.innerHTML = '<p class="text-sm text-gray-400 italic py-2">Tag already added to task</p>';
                } else {
                    tagsGrid.innerHTML = '';
                }
            } catch (error) {
                console.error('Error searching tags:', error);
            }
        }, 150);
    }

    // Handle Enter key in tag input
    function handleTagKeydown(event, input, taskId) {
        if (event.key === 'Enter') {
            event.preventDefault();
            const query = input.value.trim();
            if (query.length > 0) {
                createTagWithColor(taskId);
            }
        } else if (event.key === 'Escape') {
            const container = input.closest('.add-tag-container');
            const dropdown = container.querySelector('.tag-dropdown');
            dropdown.classList.add('hidden');
            closeColorPicker();
            input.value = '';
        }
    }

    // Open color picker
    function openColorPicker(btn) {
        const popup = btn.closest('.create-tag-section').querySelector('.color-picker-popup');
        popup.classList.toggle('hidden');
    }

    // Close color picker
    function closeColorPicker() {
        const popups = document.querySelectorAll('.color-picker-popup');
        popups.forEach(p => p.classList.add('hidden'));
    }

    // Select tag color
    function selectTagColor(color) {
        selectedTagColor = color;
        const preview = document.querySelector('.new-tag-preview');
        if (preview) {
            preview.style.backgroundColor = color;
            preview.style.setProperty('--tag-color', color);
        }
        closeColorPicker();
    }

    // Add an existing tag to the task
    async function addExistingTag(taskId, tagId, tagName, tagColor) {
        console.log('addExistingTag called', { taskId, tagId, tagName, tagColor });

        const container = document.querySelector('.tags-container');
        const dropdown = container.querySelector('.tag-dropdown');
        const input = container.querySelector('.tag-search-input');

        dropdown.classList.add('hidden');
        input.value = '';

        try {
            console.log('Sending POST to', `/tasks/${taskId}/tags`);
            const response = await fetch(`${BASE_PATH}/tasks/${taskId}/tags`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({ name: tagName })
            });

            console.log('Response status:', response.status);

            if (!response.ok) {
                const errorData = await response.json();
                console.error('Error response:', errorData);
                throw new Error(errorData.error || 'Failed to add tag');
            }

            const data = await response.json();
            console.log('Success response:', data);
            addTagChipToUI(data.tag);
            Toastr.success('Tag added');
            input.focus();
        } catch (error) {
            console.error('Error adding tag:', error);
            Toastr.error('Failed to add tag');
            input.focus();
        }
    }

    // Create a new tag with selected color and add it to the task
    async function createTagWithColor(taskId) {
        const container = document.querySelector('.tags-container');
        const dropdown = container.querySelector('.tag-dropdown');
        const input = container.querySelector('.tag-search-input');
        const tagName = input.value.trim();

        console.log('createTagWithColor called', { taskId, tagName, selectedTagColor });

        if (!tagName) {
            console.log('Empty tag name, returning');
            return;
        }

        dropdown.classList.add('hidden');
        const savedTagName = tagName; // Save before clearing input
        input.value = '';

        // Check if tag already exists on task
        const existingChips = container.querySelectorAll('.tags-list > .tag-chip');
        for (const chip of existingChips) {
            if (chip.textContent.trim().toLowerCase() === savedTagName.toLowerCase()) {
                Toastr.info('Tag already added');
                input.focus();
                return;
            }
        }

        try {
            console.log('Sending POST to', `/tasks/${taskId}/tags`);
            const response = await fetch(`${BASE_PATH}/tasks/${taskId}/tags`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({ name: savedTagName, color: selectedTagColor })
            });

            console.log('Response status:', response.status);

            if (!response.ok) {
                const errorData = await response.json();
                console.error('Error response:', errorData);
                throw new Error(errorData.error || 'Failed to create tag');
            }

            const data = await response.json();
            console.log('Success response:', data);
            addTagChipToUI(data.tag);
            Toastr.success('Tag created');
            input.focus();

            // Reset color to default for next tag
            selectedTagColor = '#3b82f6';
        } catch (error) {
            console.error('Error creating tag:', error);
            Toastr.error(error.message || 'Failed to add tag');
            input.focus();
        }
    }

    // Add tag chip to the UI
    function addTagChipToUI(tag) {
        const container = document.querySelector('.tags-container');
        const tagsList = container.querySelector('.tags-list');
        const taskId = container.dataset.taskId;

        // Remove "No tags" message
        const noMsg = container.parentElement.querySelector('.no-tags-msg');
        if (noMsg) noMsg.remove();

        const chip = document.createElement('span');
        chip.className = 'tag-chip group relative inline-flex items-center text-xs font-medium text-white pl-2 pr-5 py-0.5';
        chip.style.backgroundColor = tag.color;
        chip.style.setProperty('--tag-color', tag.color);
        chip.dataset.tagId = tag.id;
        chip.innerHTML = `
            ${escapeHtml(tag.name)}
            <button type="button"
                    onclick="removeTag('${taskId}', '${tag.id}', this)"
                    class="absolute right-0.5 top-1/2 -translate-y-1/2 h-4 w-4 items-center justify-center rounded-full hover:bg-black/20 hidden group-hover:inline-flex">
                <svg class="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        `;
        tagsList.appendChild(chip);
    }

    // Remove tag from task
    async function removeTag(taskId, tagId, btn) {
        const chip = btn.closest('.tag-chip');
        chip.style.opacity = '0.5';

        try {
            const response = await fetch(`${BASE_PATH}/tasks/${taskId}/tags/${tagId}`, {
                method: 'DELETE',
                headers: { 'X-Requested-With': 'XMLHttpRequest' }
            });

            if (!response.ok) throw new Error('Failed to remove tag');

            chip.remove();

            // Show "No tags" if empty
            const container = document.querySelector('.tags-container');
            const chips = container.querySelectorAll('.tag-chip');
            if (chips.length === 0) {
                const noMsg = document.createElement('p');
                noMsg.className = 'no-tags-msg text-sm text-gray-400 italic mt-2';
                noMsg.textContent = 'No tags';
                container.parentElement.appendChild(noMsg);
            }

            Toastr.success('Tag removed');
        } catch (error) {
            console.error('Error removing tag:', error);
            chip.style.opacity = '1';
            Toastr.error('Failed to remove tag');
        }
    }

    // Close tag dropdown when clicking outside
    document.addEventListener('click', function(e) {
        if (!e.target.closest('.add-tag-container')) {
            const dropdowns = document.querySelectorAll('.tag-dropdown');
            dropdowns.forEach(d => d.classList.add('hidden'));
            closeColorPicker();
        }
        if (!e.target.closest('.color-picker-popup') && !e.target.closest('.color-picker-btn')) {
            closeColorPicker();
        }
    });

    // ===== DETAIL PAGE TAB FUNCTIONS =====
    function switchDetailTab(tabName, btn) {
        // Update button states
        const container = btn.closest('.task-detail-tabs');
        container.querySelectorAll('.tab-btn').forEach(b => {
            b.classList.remove('active', 'text-gray-700', 'border-primary-500');
            b.classList.add('text-gray-500', 'border-transparent');
        });
        btn.classList.add('active', 'text-gray-700', 'border-primary-500');
        btn.classList.remove('text-gray-500', 'border-transparent');

        // Show/hide tab content
        container.querySelectorAll('.detail-tab-content').forEach(content => {
            content.classList.add('hidden');
        });
        document.getElementById('detail-tab-' + tabName).classList.remove('hidden');
    }

    // Trigger Vue ActivityLog component to load
    function triggerVueActivityLoad() {
        // Dispatch custom event that Vue component listens for
        document.dispatchEvent(new CustomEvent('load-activity'));
    }

    // ===== ACTIVITY TAB FUNCTIONS =====
    async function loadActivityTab(taskId) {
        // For panel: find activity container in the tab
        const activityTab = document.getElementById('tab-activity');
        if (!activityTab) return;

        const container = activityTab.querySelector('.activity-container');
        if (container) {
            await loadActivityForContainer(container);
        }
    }

    async function loadActivityForContainer(container) {
        if (!container) return;

        // Only load once
        if (container.dataset.loaded === 'true') return;

        const taskId = container.dataset.taskId;
        const loadingEl = container.querySelector('.activity-loading');
        const listEl = container.querySelector('.activity-list');
        const noActivityEl = container.querySelector('.no-activity-msg');

        try {
            const response = await fetch(`${BASE_PATH}/tasks/${taskId}/activity`, {
                headers: { 'X-Requested-With': 'XMLHttpRequest' }
            });

            if (!response.ok) throw new Error('Failed to load activity');

            const data = await response.json();
            const activities = data.activities;

            loadingEl.classList.add('hidden');

            if (activities.length === 0) {
                noActivityEl.classList.remove('hidden');
            } else {
                listEl.innerHTML = activities.map(activity => formatActivityItem(activity)).join('');
                listEl.classList.remove('hidden');
            }

            container.dataset.loaded = 'true';
        } catch (error) {
            console.error('Error loading activity:', error);
            loadingEl.innerHTML = '<p class="text-sm text-red-500">Failed to load activity</p>';
        }
    }

    function formatActivityItem(activity) {
        const icon = getActivityIcon(activity.action);
        const description = formatActivityDescription(activity);

        return `
            <div class="activity-item flex gap-3 py-2">
                <div class="flex-shrink-0">
                    <span class="inline-flex h-8 w-8 items-center justify-center rounded-full bg-gray-100">
                        ${icon}
                    </span>
                </div>
                <div class="flex-1 min-w-0">
                    <p class="text-sm text-gray-900">
                        <span class="font-medium">${escapeHtml(activity.user.fullName)}</span>
                        <span class="text-gray-600">${description}</span>
                    </p>
                    <p class="text-xs text-gray-500 mt-0.5">${activity.createdAt}</p>
                </div>
            </div>
        `;
    }

    function getActivityIcon(action) {
        const icons = {
            'created': '<svg class="h-4 w-4 text-green-600" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15" /></svg>',
            'status_changed': '<svg class="h-4 w-4 text-blue-600" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M7.5 21L3 16.5m0 0L7.5 12M3 16.5h13.5m0-13.5L21 7.5m0 0L16.5 12M21 7.5H7.5" /></svg>',
            'priority_changed': '<svg class="h-4 w-4 text-yellow-600" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3 4.5h14.25M3 9h9.75M3 13.5h9.75m4.5-4.5v12m0 0l-3.75-3.75M17.25 21l3.75-3.75" /></svg>',
            'milestone_changed': '<svg class="h-4 w-4 text-purple-600" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3 3v1.5M3 21v-6m0 0l2.77-.693a9 9 0 016.208.682l.108.054a9 9 0 006.086.71l3.114-.732a48.524 48.524 0 01-.005-10.499l-3.11.732a9 9 0 01-6.085-.711l-.108-.054a9 9 0 00-6.208-.682L3 4.5M3 15V4.5" /></svg>',
            'assigned': '<svg class="h-4 w-4 text-primary-600" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7.5v3m0 0v3m0-3h3m-3 0h-3m-2.25-4.125a3.375 3.375 0 11-6.75 0 3.375 3.375 0 016.75 0zM4 19.235v-.11a6.375 6.375 0 0112.75 0v.109A12.318 12.318 0 0110.374 21c-2.331 0-4.512-.645-6.374-1.766z" /></svg>',
            'unassigned': '<svg class="h-4 w-4 text-gray-500" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M22 10.5h-6m-2.25-4.125a3.375 3.375 0 11-6.75 0 3.375 3.375 0 016.75 0zM4 19.235v-.11a6.375 6.375 0 0112.75 0v.109A12.318 12.318 0 0110.374 21c-2.331 0-4.512-.645-6.374-1.766z" /></svg>',
            'commented': '<svg class="h-4 w-4 text-gray-600" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.625 12a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H8.25m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H12m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0h-.375M21 12c0 4.556-4.03 8.25-9 8.25a9.764 9.764 0 01-2.555-.337A5.972 5.972 0 015.41 20.97a5.969 5.969 0 01-.474-.065 4.48 4.48 0 00.978-2.025c.09-.457-.133-.901-.467-1.226C3.93 16.178 3 14.189 3 12c0-4.556 4.03-8.25 9-8.25s9 3.694 9 8.25z" /></svg>',
            'updated': '<svg class="h-4 w-4 text-gray-500" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10" /></svg>',
        };
        return icons[action] || icons['updated'];
    }

    function formatActivityDescription(activity) {
        const action = activity.action;
        const metadata = activity.metadata || {};

        switch (action) {
            case 'created':
                return ' created this task';
            case 'status_changed':
                return ` changed status from <span class="font-medium">${escapeHtml(metadata.from || '')}</span> to <span class="font-medium">${escapeHtml(metadata.to || '')}</span>`;
            case 'priority_changed':
                return ` changed priority from <span class="font-medium">${escapeHtml(metadata.from || '')}</span> to <span class="font-medium">${escapeHtml(metadata.to || '')}</span>`;
            case 'milestone_changed':
                return ` moved to milestone <span class="font-medium">${escapeHtml(metadata.to || '')}</span>`;
            case 'assigned':
                return ` assigned <span class="font-medium">${escapeHtml(metadata.assignee || '')}</span>`;
            case 'unassigned':
                return ` unassigned <span class="font-medium">${escapeHtml(metadata.assignee || '')}</span>`;
            case 'commented':
                return ' added a comment';
            case 'updated':
                return formatUpdatedDescription(metadata);
            default:
                return ` ${activity.actionLabel}`;
        }
    }

    function formatUpdatedDescription(metadata) {
        const changes = metadata.changes || {};

        if (changes.title) {
            return ` changed title from <span class="font-medium">${escapeHtml(changes.title.from || '')}</span> to <span class="font-medium">${escapeHtml(changes.title.to || '')}</span>`;
        }
        if (changes.dueDate) {
            const from = changes.dueDate.from || 'none';
            const to = changes.dueDate.to || 'none';
            return ` changed due date from <span class="font-medium">${escapeHtml(from)}</span> to <span class="font-medium">${escapeHtml(to)}</span>`;
        }
        if (changes.startDate) {
            const from = changes.startDate.from || 'none';
            const to = changes.startDate.to || 'none';
            return ` changed start date from <span class="font-medium">${escapeHtml(from)}</span> to <span class="font-medium">${escapeHtml(to)}</span>`;
        }
        return ' updated this task';
    }
    </script>
</div>
{% endblock %}
